#!/bin/bash

gethelp() {
	echo "usage: gitp [[-n] <commit message>][-f <ssh address>] [-h]"
	echo "	no arguments to pull"
	echo "	-f: first commit"
	echo "	-h: help"
	echo "	-m: make git dotfiles"
	echo "	-n: no push (offline option)"
	echo "	-s: get status"
}

showstatus() {
	echo -e "\033[02;37m$1\033[0;39m"
}

gitcommit() {
	ismaster=`git rev-parse --abbrev-ref HEAD | grep master`
	if [ -n "${ismaster}" ]; then
		echo "Warning: It looks like you are committing to master branch."
		echo "Are you sure? [y/n]"
		read answer
		case "$answer" in [yY]*) ;; *) echo "abort." ; exit 1 ;; esac
	fi
	git_root_path=`git rev-parse --show-toplevel`
	exist_gitignore=`ls -a "${git_root_path}" | grep .gitignore`
	if [ -z "${git_root_path}" ]; then
		exist_gitignore=`ls -a | grep .gitignore`
	fi
	if [ -z "${exist_gitignore}" ]; then
		echo "Warning: It looks like \".gitignore\" does not exist."
		echo "Are you sure? [y/n]"
		read answer
		case "$answer" in [yY]*) ;; *) echo "abort." ; exit 1 ;; esac
	fi
	filesOver99MB=`find . -size +99M | grep -v .git/`
	if [ -n "${filesOver99MB}" ]; then
		filesOver99MB=`echo ${filesOver99MB} | sed -e s/^/'	'/g`
		echo "Warning: It looks like you are committing files over 99MB. See below..."
		echo "${filesOver99MB}"
		echo "Are you sure? [y/n]"
		read answer
		case "$answer" in [yY]*) ;; *) echo "abort." ; exit 1 ;; esac
	fi
	git add -A
	git commit -m "$1"
}

makeGitFiles() {
	reponame=''
	notgitrepo=`git status 2>&1 | grep 'not a git repository'`
	if [ -n "${notgitrepo}" ]; then
		echo "Warning: It looks like this is not a git repository yet."
		echo "Create git files? [y/n]"
		read answer
		case "$answer" in [yY]*) ;; *) echo "abort." ; exit 1 ;; esac
	else
		currentpath=`pwd`
		reponame=`basename "${currentpath}"`
	fi
	if [ -z `ls -a | grep --ignore-case readme` ]; then
		touch readme.md
		echo "# ${reponame}" > readme.md
		echo '' >> readme.md
		showstatus "create: readme.md"
	fi
	if [ -z `ls -a | grep --ignore-case .gitignore` ]; then
		touch .gitignore
		showstatus "create: .gitignore"
	fi
	if [ -z `ls -a | grep --ignore-case .gitattributes` ]; then
		touch .gitattributes
		showstatus "create: .gitattributes"
	fi
}

while getopts nf:hsm OPT
do
	case $OPT in
		n)	status="no_push"
			;;
		f)	status="first_commit"
			address=$OPTARG
			# echo $address
			if [ -z $address ]; then
				exit 1
			fi
			;;
		h)	status="help"
			gethelp
			exit 0
			;;
		s)	status="git_status"
			git status
			exit 0
			;;
		m)	status="make_gitfiles"
			makeGitFiles
			exit 0
			;;
		\?) status="unexpected_option"
			echo "$OPTARG"
			showstatus error
			gethelp
			exit 0
			;;
	esac
done

if [ $# -eq 0 ]; then
	showstatus pulling...
	git pull
	exit 0
elif [ "$status" = "no_push" ]; then
	commit_message=${@:2:($#-1)}
	showstatus committing...
	gitcommit "${commit_message}"
	exit 0
elif [ -z $status ]; then
	commit_message=$*
	showstatus pulling...
	git pull
	showstatus committing...
	gitcommit "${commit_message}"
	showstatus pushing...
	if [ ! -d "$HOME/.custom-commands/tmp" ]; then
		mkdir "$HOME/.custom-commands/tmp"
	fi
	# { git push 3>&2 2>&1 1>&3 | tee "$HOME/.custom-commands/tmp/gitp_error"; } 3>&2 2>&1 1>&3
	{ { git push 1>&3; } 2>&1 | tee "$HOME/.custom-commands/tmp/gitp_error" 1>&2; } 3>&1
	retry_cmd=`cat "$HOME/.custom-commands/tmp/gitp_error" | grep 'git push --set-upstream origin'`
	# retry_cmd=`echo ${retry_cmd} | tr -d " "`
	retry_cmd=`echo ${retry_cmd} | sed -e "/^ /d"`
	eval "${retry_cmd}"
	# if [ -n ${retry_cmd} ]; then
	# 	showstatus retrying...
	# 	eval "${retry_cmd}"
	# fi
	rm "$HOME/.custom-commands/tmp/gitp_error"
	echo ''
	echo 'âœ¨ Done'
	exit 0
fi

if [ -n $address ]; then
	git init
	gitcommit "first commit"
	git remote add origin $address
	git push -u origin master
	exit 0
fi

# warning: push.default is unset; its implicit value has changed in
# Git 2.0 from 'matching' to 'simple'. To squelch this message
# and maintain the traditional behavior, use:

#   git config --global push.default matching

# To squelch this message and adopt the new behavior now, use:

#   git config --global push.default simple

# When push.default is set to 'matching', git will push local branches
# to the remote branches that already exist with the same name.

# Since Git 2.0, Git defaults to the more conservative 'simple'
# behavior, which only pushes the current branch to the corresponding
# remote branch that 'git pull' uses to update the current branch.

# See 'git help config' and search for 'push.default' for further information.
# (the 'simple' mode was introduced in Git 1.7.11. Use the similar mode
# 'current' instead of 'simple' if you sometimes use older versions of Git)
